# Owner: platform
name: Bootstrap - CI Bootstrap (Stub)

on:
  workflow_dispatch:
    inputs:
      env:
        description: "Environment to target (dev/test/staging/prod)"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - test
          - staging
          - prod
      region:
        description: "AWS region"
        required: true
        default: "eu-west-2"
      cluster_name:
        description: "EKS cluster name"
        required: false
        default: ""
      lifecycle:
        description: "Lifecycle (ephemeral or persistent)"
        required: true
        default: "ephemeral"
        type: choice
        options:
          - ephemeral
          - persistent
      bootstrap_version:
        description: "Bootstrap script version"
        required: true
        default: "v1"
        type: choice
        options:
          - v1
          - v2
      config_source:
        description: "Config source (repo tfvars or workflow inputs)"
        required: true
        default: "repo"
        type: choice
        options:
          - repo
          - inputs
      tfvars_b64:
        description: "Base64-encoded tfvars (required when config_source=inputs)"
        required: false
        default: ""
      build_id:
        description: "Build ID (required for ephemeral)"
        required: false
        default: ""
      bootstrap_only:
        description: "Bootstrap only (skip Terraform apply)"
        required: true
        default: true
        type: boolean
      new_build:
        description: "New build (fail if state already exists)"
        required: true
        default: false
        type: boolean
      confirm_irsa_apply:
        description: "Confirm IRSA service-account apply (required for LB + autoscaler; future EFS/EBS)"
        required: true
        default: true
        type: boolean
      node_instance_type:
        description: "Node instance type (bootstrap)"
        required: true
        default: "t3.small"
      min_ready_nodes:
        description: "Minimum Ready nodes required"
        required: true
        default: "3"
      skip_argo_sync_wait:
        description: "Skip Argo sync wait"
        required: true
        default: "true"
        type: boolean
      skip_cert_manager_validation:
        description: "Skip cert-manager validation"
        required: true
        default: "true"
        type: boolean
      compact_output:
        description: "Compact output"
        required: true
        default: "false"
        type: boolean

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      ENV: ${{ inputs.env }}
      AWS_REGION: ${{ inputs.region }}
      CLUSTER_NAME: ${{ inputs.cluster_name }}
      BUILD_ID: ${{ inputs.build_id }}
      CLUSTER_LIFECYCLE: ${{ inputs.lifecycle }}
      TF_VAR_build_id: ${{ inputs.build_id }}
      TF_VAR_cluster_lifecycle: ${{ inputs.lifecycle }}
      TF_DIR: envs/${{ inputs.env }}
      MIN_READY_NODES: ${{ inputs.min_ready_nodes }}
      CONFIRM_TF_APPLY: ${{ inputs.confirm_irsa_apply }}
      BOOTSTRAP_VERSION: ${{ inputs.bootstrap_version }}
      LB_CLEANUP_ATTEMPTS: "5"
      LB_CLEANUP_INTERVAL: "20"
      REMOVE_K8S_SA_FROM_STATE: "true"
      ENABLE_TF_K8S_RESOURCES: "true"
      SCALE_DOWN_AFTER_BOOTSTRAP: "false"
      TF_AUTO_APPROVE: "true"
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC (bootstrap)
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          aws-region: ${{ inputs.region }}
          role-to-assume: ${{ secrets.TF_AWS_IAM_ROLE_DEV_APPLY }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      # Phase 1: Preflight + tooling
      # Goal: ensure CLI tools are available and inputs are valid before any changes.
      - name: Phase 1 - Preflight checks (stub)
        run: |
          echo "Phase 1: validate inputs and tools"
          echo "ENV=${ENV}"
          echo "AWS_REGION=${AWS_REGION}"
          echo "CLUSTER_LIFECYCLE=${CLUSTER_LIFECYCLE}"
          echo "BUILD_ID=${BUILD_ID}"
          if [[ "${CLUSTER_LIFECYCLE}" == "ephemeral" ]]; then
            if [[ -z "${BUILD_ID}" ]]; then
              echo "BUILD_ID is required when lifecycle=ephemeral." >&2
              exit 1
            fi
          fi
          if [[ "${{ inputs.config_source }}" == "inputs" ]] && [[ -z "${{ inputs.tfvars_b64 }}" ]]; then
            echo "tfvars_b64 is required when config_source=inputs." >&2
            exit 1
          fi
          if [[ -n "${BUILD_ID}" ]] && ! echo "${BUILD_ID}" | grep -Eq '^[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}$'; then
            echo "Invalid BUILD_ID: ${BUILD_ID} (expected dd-mm-yy-NN)" >&2
            exit 1
          fi
          if ! echo "${MIN_READY_NODES}" | grep -Eq '^[0-9]+$'; then
            echo "MIN_READY_NODES must be numeric; got ${MIN_READY_NODES}." >&2
            exit 1
          fi
          if [[ "${ENABLE_TF_K8S_RESOURCES}" == "true" ]] && [[ "${{ inputs.confirm_irsa_apply }}" != "true" ]]; then
            echo "IRSA service-account apply requires confirm_irsa_apply=true." >&2
            exit 1
          fi

      - name: Configure tfvars source
        run: |
          if [[ "${{ inputs.config_source }}" == "inputs" ]]; then
            tfvars_path="${GITHUB_WORKSPACE}/.bootstrap.tfvars"
            echo "${{ inputs.tfvars_b64 }}" | base64 --decode > "${tfvars_path}"
            echo "TFVARS_PATH=${tfvars_path}" >> "${GITHUB_ENV}"
            echo "Using tfvars from workflow input."
          else
            echo "TFVARS_PATH=${GITHUB_WORKSPACE}/${TF_DIR}/terraform.tfvars" >> "${GITHUB_ENV}"
            echo "Using tfvars from repo (${TF_DIR}/terraform.tfvars)."
          fi

      - name: Resolve cluster name
        run: |
          if [[ -z "${CLUSTER_NAME}" ]]; then
            CLUSTER_NAME="$(ENV=${ENV} TF_DIR=${TF_DIR} BUILD_ID=${BUILD_ID} CLUSTER_LIFECYCLE=${CLUSTER_LIFECYCLE} bash scripts/resolve-cluster-name.sh)"
          fi
          echo "CLUSTER_NAME=${CLUSTER_NAME}" >> "${GITHUB_ENV}"
          echo "Resolved CLUSTER_NAME=${CLUSTER_NAME}"

      - name: Resolve backend config
        id: backend
        run: |
          case "${ENV}" in
            dev)
              echo "bucket=goldenpath-idp-dev-bucket" >> "$GITHUB_OUTPUT"
              echo "table=goldenpath-idp-dev-db-key" >> "$GITHUB_OUTPUT"
              ;;
            test)
              echo "bucket=goldenpath-test-staging-bucket" >> "$GITHUB_OUTPUT"
              echo "table=goldenpath-idp-test-db" >> "$GITHUB_OUTPUT"
              ;;
            staging)
              echo "bucket=goldenpath-idp-staging-bucket" >> "$GITHUB_OUTPUT"
              echo "table=goldenpath-idp-staging-db" >> "$GITHUB_OUTPUT"
              ;;
            prod)
              echo "bucket=goldenpath-idp-prod-bucket" >> "$GITHUB_OUTPUT"
              echo "table=goldenpath-idp-prod-db" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "Unsupported env: ${ENV}" >&2
              exit 1
              ;;
          esac

      - name: Resolve state key
        run: |
          if [[ "${CLUSTER_LIFECYCLE}" == "ephemeral" ]]; then
            STATE_KEY="envs/${ENV}/builds/${BUILD_ID}/terraform.tfstate"
          else
            STATE_KEY="envs/${ENV}/terraform.tfstate"
          fi
          echo "STATE_KEY=${STATE_KEY}" >> "${GITHUB_ENV}"
          echo "Resolved STATE_KEY=${STATE_KEY}"

      - name: Bootstrap config summary
        if: always()
        run: |
          {
            echo "Bootstrap config"
            echo "- bootstrap_version: ${BOOTSTRAP_VERSION}"
            echo "- env: ${ENV}"
            echo "- region: ${AWS_REGION}"
            echo "- lifecycle: ${CLUSTER_LIFECYCLE}"
            echo "- build_id: ${BUILD_ID:-<empty>}"
            echo "- cluster_name: ${CLUSTER_NAME}"
            echo "- config_source: ${{ inputs.config_source }}"
            echo "- tfvars_path: ${TFVARS_PATH}"
            echo "- state_key: ${STATE_KEY}"
            echo "- enable_tf_k8s_resources: ${ENABLE_TF_K8S_RESOURCES}"
            echo "- confirm_irsa_apply: ${{ inputs.confirm_irsa_apply }}"
            echo "- skip_argo_sync_wait: ${{ inputs.skip_argo_sync_wait }}"
            echo "- skip_cert_manager_validation: ${{ inputs.skip_cert_manager_validation }}"
            echo "- compact_output: ${{ inputs.compact_output }}"
            echo "- min_ready_nodes: ${MIN_READY_NODES}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Guard - backend state
        run: |
          echo "Checking state: s3://${{ steps.backend.outputs.bucket }}/${STATE_KEY}"
          if [[ "${CLUSTER_LIFECYCLE}" == "persistent" ]]; then
            if ! aws s3api head-object --bucket "${{ steps.backend.outputs.bucket }}" --key "${STATE_KEY}" >/dev/null 2>&1; then
              echo "Missing state file in backend. Run infra apply first or migrate local state." >&2
              exit 1
            fi
          else
            if aws s3api head-object --bucket "${{ steps.backend.outputs.bucket }}" --key "${STATE_KEY}" >/dev/null 2>&1; then
              if [[ "${{ inputs.new_build }}" == "true" ]]; then
                echo "State already exists for BUILD_ID=${BUILD_ID}. New build requested, aborting to avoid append." >&2
                exit 1
              fi
              echo "Found existing state for BUILD_ID=${BUILD_ID}. Reusing state for resume."
            else
              if [[ "${{ inputs.new_build }}" == "true" ]]; then
                echo "No state found for BUILD_ID=${BUILD_ID}. New build confirmed."
              else
                echo "No state found for BUILD_ID=${BUILD_ID}. A fresh state will be created on apply."
              fi
            fi
          fi

      - name: Terraform init (backend)
        run: |
          terraform -chdir="${TF_DIR}" init \
            -backend-config="bucket=${{ steps.backend.outputs.bucket }}" \
            -backend-config="key=${STATE_KEY}" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${{ steps.backend.outputs.table }}" \
            -backend-config="encrypt=true"

      # Timing note (baseline, non-blocking)
      - name: Timing log (stub)
        run: |
          echo "CI timing log"
          echo "Start: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "End:   $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "Capture timestamps around real apply/bootstrap steps once wired."

      # Phase 2+3: Timed build + bootstrap (ephemeral only)
      # Goal: capture build/teardown timing while keeping lifecycle deterministic.
      - name: Phase 2+3 - Timed build + bootstrap (stub)
        if: ${{ !inputs.bootstrap_only && inputs.lifecycle == 'ephemeral' }}
        run: |
          TF_VAR_cluster_lifecycle="${CLUSTER_LIFECYCLE}" \
          TF_VAR_build_id="${BUILD_ID}" \
          TF_VAR_owner_team="platform-team" \
          ENV_NAME="${ENV}" \
          NODE_INSTANCE_TYPE="${{ inputs.node_instance_type }}" \
          MIN_READY_NODES="${MIN_READY_NODES}" \
          SKIP_ARGO_SYNC_WAIT="${{ inputs.skip_argo_sync_wait }}" \
          SKIP_CERT_MANAGER_VALIDATION="${{ inputs.skip_cert_manager_validation }}" \
          COMPACT_OUTPUT="${{ inputs.compact_output }}" \
          ENABLE_TF_K8S_RESOURCES="${ENABLE_TF_K8S_RESOURCES}" \
          SCALE_DOWN_AFTER_BOOTSTRAP="${SCALE_DOWN_AFTER_BOOTSTRAP}" \
          CONFIRM_TF_APPLY="${CONFIRM_TF_APPLY}" \
          TF_DIR="${TF_DIR}" \
          TFVARS_PATH="${TFVARS_PATH}" \
          CLUSTER="${CLUSTER_NAME}" \
          REGION="${AWS_REGION}" \
          make timed-build ENV="${ENV}" BUILD_ID="${BUILD_ID}" CLUSTER="${CLUSTER_NAME}" REGION="${AWS_REGION}"

      - name: Reliability metrics summary (timed build)
        if: ${{ always() && !inputs.bootstrap_only && inputs.lifecycle == 'ephemeral' }}
        run: |
          make reliability-metrics

      # Phase 2: Terraform init/plan/apply (persistent)
      # Goal: provision or update infra deterministically.
      - name: Phase 2 - Terraform (stub)
        if: ${{ !inputs.bootstrap_only && inputs.lifecycle != 'ephemeral' }}
        run: |
          TF_VAR_cluster_lifecycle="${CLUSTER_LIFECYCLE}" \
          TF_VAR_build_id="${BUILD_ID}" \
          TF_VAR_owner_team="platform-team" \
          make apply ENV="${ENV}" BUILD_ID="${BUILD_ID}"

      # Phase 3: Bootstrap runner (persistent)
      # Goal: install core platform tooling in the enforced order.
      - name: Phase 3 - Bootstrap runner (stub)
        if: ${{ !inputs.bootstrap_only && inputs.lifecycle != 'ephemeral' }}
        run: |
          ENV_NAME="${ENV}" \
          NODE_INSTANCE_TYPE="${{ inputs.node_instance_type }}" \
          MIN_READY_NODES="${MIN_READY_NODES}" \
          SKIP_ARGO_SYNC_WAIT="${{ inputs.skip_argo_sync_wait }}" \
          SKIP_CERT_MANAGER_VALIDATION="${{ inputs.skip_cert_manager_validation }}" \
          COMPACT_OUTPUT="${{ inputs.compact_output }}" \
          ENABLE_TF_K8S_RESOURCES="${ENABLE_TF_K8S_RESOURCES}" \
          SCALE_DOWN_AFTER_BOOTSTRAP="${SCALE_DOWN_AFTER_BOOTSTRAP}" \
          CONFIRM_TF_APPLY="${CONFIRM_TF_APPLY}" \
          TF_DIR="${TF_DIR}" \
          TFVARS_PATH="${TFVARS_PATH}" \
          CLUSTER="${CLUSTER_NAME}" \
          REGION="${AWS_REGION}" \
          make bootstrap ENV="${ENV}" BUILD_ID="${BUILD_ID}"

      # Phase 3: Timed bootstrap-only (when build_id is available)
      - name: Phase 3 - Timed bootstrap only (stub)
        if: ${{ inputs.bootstrap_only && inputs.build_id != '' }}
        run: |
          ENV_NAME="${ENV}" \
          NODE_INSTANCE_TYPE="${{ inputs.node_instance_type }}" \
          MIN_READY_NODES="${MIN_READY_NODES}" \
          SKIP_ARGO_SYNC_WAIT="${{ inputs.skip_argo_sync_wait }}" \
          SKIP_CERT_MANAGER_VALIDATION="${{ inputs.skip_cert_manager_validation }}" \
          COMPACT_OUTPUT="${{ inputs.compact_output }}" \
          ENABLE_TF_K8S_RESOURCES="${ENABLE_TF_K8S_RESOURCES}" \
          SCALE_DOWN_AFTER_BOOTSTRAP="${SCALE_DOWN_AFTER_BOOTSTRAP}" \
          CONFIRM_TF_APPLY="${CONFIRM_TF_APPLY}" \
          TF_DIR="${TF_DIR}" \
          TFVARS_PATH="${TFVARS_PATH}" \
          CLUSTER="${CLUSTER_NAME}" \
          REGION="${AWS_REGION}" \
          make timed-bootstrap ENV="${ENV}" BUILD_ID="${BUILD_ID}" CLUSTER="${CLUSTER_NAME}" REGION="${AWS_REGION}"

      - name: Reliability metrics summary (timed bootstrap)
        if: ${{ always() && inputs.bootstrap_only && inputs.build_id != '' }}
        run: |
          make reliability-metrics

      # Phase 3: Bootstrap-only fallback (no build_id)
      - name: Phase 3 - Bootstrap only (stub)
        if: ${{ inputs.bootstrap_only && inputs.build_id == '' }}
        run: |
          ENV_NAME="${ENV}" \
          NODE_INSTANCE_TYPE="${{ inputs.node_instance_type }}" \
          MIN_READY_NODES="${MIN_READY_NODES}" \
          SKIP_ARGO_SYNC_WAIT="${{ inputs.skip_argo_sync_wait }}" \
          SKIP_CERT_MANAGER_VALIDATION="${{ inputs.skip_cert_manager_validation }}" \
          COMPACT_OUTPUT="${{ inputs.compact_output }}" \
          ENABLE_TF_K8S_RESOURCES="${ENABLE_TF_K8S_RESOURCES}" \
          SCALE_DOWN_AFTER_BOOTSTRAP="${SCALE_DOWN_AFTER_BOOTSTRAP}" \
          CONFIRM_TF_APPLY="${CONFIRM_TF_APPLY}" \
          TF_DIR="${TF_DIR}" \
          TFVARS_PATH="${TFVARS_PATH}" \
          CLUSTER="${CLUSTER_NAME}" \
          REGION="${AWS_REGION}" \
          make bootstrap ENV="${ENV}" BUILD_ID="${BUILD_ID}"

      # Phase 4: Post-bootstrap validation
      # Goal: capture a deterministic status summary for CI logs.
      - name: Phase 4 - Post-bootstrap checks (stub)
        run: |
          echo "Phase 4: sanity checks and Argo status summary go here"
          echo "kubectl get nodes"
          echo "kubectl -n argocd get applications"
      - name: Runbook link
        if: always()
        run: |
          {
            echo "Runbook: docs/40-delivery/39_GOLDEN_PATH_VALIDATION.md"
            echo "Runbook: docs/40-delivery/17_BUILD_RUN_FLAGS.md"
          } >> "${GITHUB_STEP_SUMMARY}"

      # Teardown runs in a separate workflow to avoid auto-destroy after bootstrap.
