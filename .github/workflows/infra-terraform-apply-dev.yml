# Owner: platform
# Relates-To: CL-0142, ADR-0028-platform-dev-branch-gate, ROADMAP-102
# Pattern: Outcome-driven CI - workflows call Make targets
#   CI says WHAT (inputs/outcomes), Make says HOW (terraform/kubectl)
#   See: docs/production-readiness-gates/ROADMAP.md item 102
name: Apply - Infra Terraform Apply (dev)

on:
  push:
    branches:
      - main
    paths:
      - "envs/dev/**/*.tf"
      - "envs/dev/**/*.tfvars"
      - "modules/**/*.tf"
  workflow_dispatch:
    inputs:
      confirm_apply:
        description: "Type 'apply' to confirm dev apply"
        required: true
        default: "cancel"
        type: choice
        options:
          - cancel
          - apply
      lifecycle:
        description: "Lifecycle (ephemeral or persistent)"
        required: true
        default: "ephemeral"
        type: choice
        options:
          - ephemeral
          - persistent
      build_id:
        description: "Build ID (dd-mm-yy-NN)"
        required: false
        type: string
      new_build:
        description: "Confirm a new ephemeral build (required when lifecycle=ephemeral)"
        required: true
        default: false
        type: boolean
      bootstrap_version:
        description: "Bootstrap version (v3=shell orchestration, v4=ArgoCD-first)"
        required: false
        default: "v4"
        type: choice
        options:
          - v4
          - v3

jobs:
  # Gate: Check if EKS-related files changed (requires manual apply)
  scope-check:
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    outputs:
      eks_changed: ${{ steps.check.outputs.eks_changed }}
      changed_files: ${{ steps.check.outputs.changed_files }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check for EKS-related changes
        id: check
        run: |
          # Get files changed in this push
          CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Check if any EKS-critical files changed
          if echo "$CHANGED" | grep -qE "modules/aws_eks/|envs/dev/main\.tf"; then
            echo "eks_changed=true" >> $GITHUB_OUTPUT
            echo "::warning::EKS-related files changed - manual apply required"
          else
            echo "eks_changed=false" >> $GITHUB_OUTPUT
            echo "::notice::No EKS changes detected - auto-apply will proceed"
          fi

  apply-dev:
    needs: [scope-check]
    # Run if:
    # 1. Manual dispatch with confirm_apply == 'apply', OR
    # 2. Push event AND no EKS files changed (safe auto-apply)
    # Skip if: Push event AND EKS files changed (requires manual trigger)
    if: |
      always() && (
        (github.event_name == 'workflow_dispatch' && inputs.confirm_apply == 'apply') ||
        (github.event_name == 'push' && needs.scope-check.outputs.eks_changed == 'false')
      )
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      contents: write
      id-token: write
      actions: read
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Fetch governance registry for build_id validation
        run: git fetch origin governance-registry:refs/remotes/origin/governance-registry

      - name: Resolve lifecycle and build_id from tfvars (auto-apply)
        if: ${{ github.event_name == 'push' }}
        id: resolve
        run: |
          read_top_var() {
            local key="$1"
            awk -F'=' -v k="${key}" '{
              line=$0
              sub(/#.*/,"",line)
              if (line ~ /^[[:space:]]*$/) next
              split(line, parts, "=")
              lhs=parts[1]; gsub(/[[:space:]]/,"",lhs)
              if (lhs==k) {
                val=parts[2]
                sub(/#.*/,"",val)
                gsub(/"/,"",val)
                gsub(/[[:space:]]/,"",val)
                print val
                exit
              }
            }' envs/dev/terraform.tfvars
          }
          LIFECYCLE=$(read_top_var "cluster_lifecycle")
          BUILD_ID=$(read_top_var "build_id")
          if [[ -z "${LIFECYCLE}" ]]; then
            LIFECYCLE="persistent"
          fi
          echo "RESOLVED_LIFECYCLE=${LIFECYCLE}" >> "${GITHUB_ENV}"
          echo "RESOLVED_BUILD_ID=${BUILD_ID}" >> "${GITHUB_ENV}"
          echo "Resolved from tfvars: lifecycle=${LIFECYCLE}, build_id=${BUILD_ID}"

      - name: Set effective lifecycle and build_id
        id: effective
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "lifecycle=${RESOLVED_LIFECYCLE}" >> "${GITHUB_OUTPUT}"
            echo "build_id=${RESOLVED_BUILD_ID}" >> "${GITHUB_OUTPUT}"
            # For push events, new_build is implicit if ephemeral
            if [[ "${RESOLVED_LIFECYCLE}" == "ephemeral" ]]; then
              echo "new_build=true" >> "${GITHUB_OUTPUT}"
            else
              echo "new_build=false" >> "${GITHUB_OUTPUT}"
            fi
            # Default to v4 for push events
            echo "bootstrap_version=v4" >> "${GITHUB_OUTPUT}"
          else
            echo "lifecycle=${{ inputs.lifecycle }}" >> "${GITHUB_OUTPUT}"
            echo "build_id=${{ inputs.build_id }}" >> "${GITHUB_OUTPUT}"
            echo "new_build=${{ inputs.new_build }}" >> "${GITHUB_OUTPUT}"
            echo "bootstrap_version=${{ inputs.bootstrap_version || 'v4' }}" >> "${GITHUB_OUTPUT}"
          fi

      - name: Validate lifecycle and build ID
        shell: bash
        env:
          LIFECYCLE: ${{ steps.effective.outputs.lifecycle }}
          BUILD_ID: ${{ steps.effective.outputs.build_id }}
          NEW_BUILD: ${{ steps.effective.outputs.new_build }}
        run: |
          if [[ "${LIFECYCLE}" == "ephemeral" ]]; then
            if [[ "${NEW_BUILD}" != "true" ]]; then
              echo "new_build must be true when lifecycle=ephemeral" >&2
              exit 1
            fi
            if [[ -z "${BUILD_ID}" ]]; then
              echo "build_id is required when lifecycle=ephemeral" >&2
              exit 1
            fi
            if ! [[ "${BUILD_ID}" =~ ^[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}$ ]]; then
              echo "Invalid build_id: '${BUILD_ID}' (expected dd-mm-yy-NN)" >&2
              exit 1
            fi
          else
            if [[ "${NEW_BUILD}" == "true" ]]; then
              echo "new_build is only valid for lifecycle=ephemeral" >&2
              exit 1
            fi
            if [[ -n "${BUILD_ID}" ]]; then
              echo "build_id is only valid for lifecycle=ephemeral" >&2
              exit 1
            fi
          fi

      - name: Verify dev plan succeeded for this commit
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const sha = context.sha;
            const lifecycle = "${{ steps.effective.outputs.lifecycle }}";
            const buildId = "${{ steps.effective.outputs.build_id }}";
            const findManualPlan = async (targetSha) => {
              const manualRuns = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: "infra-terraform.yml",
                event: "workflow_dispatch",
                per_page: 50
              });
              return manualRuns.data.workflow_runs.find(
                run =>
                  run.conclusion === "success" &&
                  run.head_sha === targetSha &&
                  typeof run.display_title === "string" &&
                  run.display_title.includes("env=dev") &&
                  run.display_title.includes(`lifecycle=${lifecycle}`) &&
                  (lifecycle !== "ephemeral" || run.display_title.includes(`build_id=${buildId}`))
              );
            };
            const findPrPlan = async (targetSha) => {
              const prRuns = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: "pr-terraform-plan.yml",
                event: "pull_request",
                per_page: 50
              });
              return prRuns.data.workflow_runs.find(
                run => run.conclusion === "success" && run.head_sha === targetSha
              );
            };

            const manualMatch = await findManualPlan(sha);
            let prMatch = await findPrPlan(sha);
            let prHeadSha = null;

            if (!prMatch) {
              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha: sha,
                per_page: 10,
                mediaType: { previews: ["groot"] }
              });
              const merged = prs.data.find(pr => pr.merged_at);
              if (merged) {
                prHeadSha = merged.head.sha;
                prMatch = await findPrPlan(prHeadSha);
              }
            }

            if (!manualMatch && !prMatch) {
              core.setFailed(
                `No successful dev plan run found for ${sha}. Run PR Terraform Plan (matching the PR head) or infra-terraform.yml with env=dev and matching lifecycle/build_id first.`
              );
            } else if (manualMatch) {
              core.info(`Dev plan run ok (manual): ${manualMatch.html_url}`);
            } else if (prHeadSha) {
              core.info(`Dev plan run ok (PR head ${prHeadSha}): ${prMatch.html_url}`);
            } else {
              core.info(`Dev plan run ok (PR): ${prMatch.html_url}`);
            }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS credentials using OIDC (apply role)
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          aws-region: eu-west-2
          role-to-assume: ${{ secrets.TF_AWS_IAM_ROLE_DEV_APPLY }}

      - name: Resolve state key
        env:
          LIFECYCLE: ${{ steps.effective.outputs.lifecycle }}
          BUILD_ID: ${{ steps.effective.outputs.build_id }}
        run: |
          if [[ "${LIFECYCLE}" == "ephemeral" ]]; then
            STATE_KEY="envs/dev/builds/${BUILD_ID}/terraform.tfstate"
          else
            STATE_KEY="envs/dev/terraform.tfstate"
          fi
          echo "STATE_KEY=${STATE_KEY}" >> "${GITHUB_ENV}"
          echo "Resolved STATE_KEY=${STATE_KEY}"

      - name: CI summary (state selection)
        run: |
          echo "Lifecycle=${{ steps.effective.outputs.lifecycle }}"
          echo "BuildId=${{ steps.effective.outputs.build_id }}"
          echo "NewBuild=${{ steps.effective.outputs.new_build }}"
          echo "BootstrapVersion=${{ steps.effective.outputs.bootstrap_version }}"
          echo "StateKey=${STATE_KEY}"

      - name: Terraform init (backend)
        run: |
          terraform -chdir=envs/dev init \
            -backend-config="bucket=goldenpath-idp-dev-bucket" \
            -backend-config="key=${STATE_KEY}" \
            -backend-config="region=eu-west-2" \
            -backend-config="dynamodb_table=goldenpath-idp-dev-db-key" \
            -backend-config="encrypt=true"

      # ==========================================================================
      # Outcome-Driven Deployment: CI says WHAT, Make says HOW
      # Pattern: ROADMAP-102 - workflows call Make targets
      # ==========================================================================
      - name: Deploy (Make target)
        id: deploy
        env:
          LIFECYCLE: ${{ steps.effective.outputs.lifecycle }}
          BUILD_ID: ${{ steps.effective.outputs.build_id }}
          BOOTSTRAP_VERSION: ${{ steps.effective.outputs.bootstrap_version }}
          AWS_REGION: eu-west-2
        run: |
          echo "TF_APPLY_START=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${GITHUB_ENV}"

          # Outcome-driven: CI specifies WHAT (inputs), Make handles HOW (implementation)
          if [[ "${LIFECYCLE}" == "persistent" ]]; then
            echo "Deploying persistent cluster via Make..."
            make deploy-persistent \
              ENV=dev \
              REGION=eu-west-2 \
              BOOTSTRAP_VERSION=${BOOTSTRAP_VERSION} \
              CREATE_RDS=true \
              TF_AUTO_APPROVE=true \
              2>&1 | tee deploy.log
          else
            echo "Deploying ephemeral cluster via Make..."
            # For ephemeral, need to setup EKS access first (CI runner-specific)
            # Then call the deploy target
            make deploy \
              ENV=dev \
              BUILD_ID=${BUILD_ID} \
              REGION=eu-west-2 \
              BOOTSTRAP_VERSION=${BOOTSTRAP_VERSION} \
              ALLOW_REUSE_BUILD_ID=true \
              2>&1 | tee deploy.log
          fi
          DEPLOY_EXIT=${PIPESTATUS[0]}

          echo "TF_APPLY_END=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${GITHUB_ENV}"

          # Extract resource counts from terraform output in log
          if grep -q "Apply complete!" deploy.log; then
            ADDED=$(grep "Apply complete!" deploy.log | tail -1 | sed -E 's/.*Resources: ([0-9]+) added.*/\1/' || echo 0)
            CHANGED=$(grep "Apply complete!" deploy.log | tail -1 | sed -E 's/.*, ([0-9]+) changed.*/\1/' || echo 0)
            DESTROYED=$(grep "Apply complete!" deploy.log | tail -1 | sed -E 's/.*, ([0-9]+) destroyed.*/\1/' || echo 0)
          else
            ADDED=0; CHANGED=0; DESTROYED=0
          fi
          echo "TF_RESOURCES_ADDED=${ADDED}" >> "${GITHUB_ENV}"
          echo "TF_RESOURCES_CHANGED=${CHANGED}" >> "${GITHUB_ENV}"
          echo "TF_RESOURCES_DESTROYED=${DESTROYED}" >> "${GITHUB_ENV}"
          echo "TF_EXIT_CODE=${DEPLOY_EXIT}" >> "${GITHUB_ENV}"

          exit ${DEPLOY_EXIT}

      - name: Record build timing to governance-registry
        if: always()
        env:
          BUILD_ID: ${{ steps.effective.outputs.build_id }}
          LIFECYCLE: ${{ steps.effective.outputs.lifecycle }}
        run: |
          # Calculate duration
          START_EPOCH=$(date -d "${TF_APPLY_START}" +%s 2>/dev/null || echo 0)
          END_EPOCH=$(date -d "${TF_APPLY_END}" +%s 2>/dev/null || echo 0)
          DURATION=$((END_EPOCH - START_EPOCH))

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Checkout governance-registry branch
          git fetch origin governance-registry
          git checkout governance-registry

          # Ensure directory exists
          mkdir -p environments/development/latest

          CSV_FILE="environments/development/latest/build_timings.csv"

          # Create CSV with header if it doesn't exist
          if [[ ! -f "$CSV_FILE" ]]; then
            echo "start_time_utc,end_time_utc,phase,env,build_id,duration_seconds,exit_code,resources_added,resources_changed,resources_destroyed,workflow_run_url" > "$CSV_FILE"
          fi

          # Append terraform-apply record
          echo "${TF_APPLY_START:-},${TF_APPLY_END:-},terraform-apply,dev,${BUILD_ID:-persistent},${DURATION},${TF_EXIT_CODE:-0},${TF_RESOURCES_ADDED:-0},${TF_RESOURCES_CHANGED:-0},${TF_RESOURCES_DESTROYED:-0},${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$CSV_FILE"

          # Commit and push
          git add "$CSV_FILE"
          git commit -m "chore(registry): record terraform-apply for dev build ${BUILD_ID:-persistent}

          Duration: ${DURATION}s
          Resources: +${TF_RESOURCES_ADDED:-0} ~${TF_RESOURCES_CHANGED:-0} -${TF_RESOURCES_DESTROYED:-0}
          Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" || echo "No changes to commit"

          git push origin governance-registry || echo "Warning: Could not push to governance-registry"

          # Return to main branch
          git checkout main || git checkout -

      - name: Runbook link
        if: always()
        run: |
          echo "Runbook: docs/20-contracts/21_CI_ENVIRONMENT_CONTRACT.md" >> "${GITHUB_STEP_SUMMARY}"
