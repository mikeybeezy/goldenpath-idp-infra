# Owner: platform-team
# Relates-To: EKS_REQUEST_FLOW, ADR-0168, PR_GUARDRAILS_INDEX
name: EKS Bootstrap (Bootstrap-Only Requests)

on:
  pull_request:
    types: [closed]
    paths:
      - "docs/20-contracts/eks-requests/**/*.yaml"
      - "docs/20-contracts/eks-requests/**/*.yml"
  workflow_dispatch:
    inputs:
      request_file:
        description: "Path to EKS request file (bootstrap-only)"
        required: true
        type: string
      platform_approved:
        description: "Platform approval acknowledged"
        required: true
        default: false
        type: boolean
      allow_non_dev:
        description: "Allow non-dev bootstrap (staging/prod)"
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  id-token: write

jobs:
  bootstrap:
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Resolve request files
        id: requests
        env:
          REQUEST_FILE: ${{ inputs.request_file }}
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "files=${REQUEST_FILE}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE="${{ github.event.pull_request.base.sha }}"
          HEAD="${{ github.event.pull_request.merge_commit_sha }}"
          if [[ -z "$HEAD" || "$HEAD" == "null" ]]; then
            HEAD="${{ github.sha }}"
          fi

          CHANGED=$(git diff --name-only "$BASE" "$HEAD" | grep -E '^docs/20-contracts/eks-requests/.+\\.ya?ml$' || true)
          echo "files<<EOF" >> "$GITHUB_OUTPUT"
          echo "$CHANGED" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Filter bootstrap-only requests
        id: bootstrap_only
        env:
          FILES: ${{ steps.requests.outputs.files }}
        run: |
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          import os
          import sys
          import yaml

          files = [f for f in os.environ.get("FILES", "").splitlines() if f.strip()]
          if not files:
            print("count=0")
            sys.exit(0)

          tier_map = {
              "small": "t3.small",
              "medium": "t3.medium",
              "large": "t3.large",
              "xlarge": "t3.xlarge",
          }

          requests = []
          for path in files:
              data = yaml.safe_load(open(path)) or {}
              spec = data.get("spec", {}) or {}
              mode = spec.get("mode")
              if mode != "bootstrap-only":
                  continue
              cluster = spec.get("cluster", {}) or {}
              node_pool = spec.get("node_pool", {}) or {}
              node_tier = node_pool.get("node_tier") or node_pool.get("tier")
              instance_type = node_pool.get("instance_type")
              if not instance_type and node_tier:
                  instance_type = tier_map.get(node_tier)
              if not instance_type:
                  raise SystemExit(f"{path}: node_tier/instance_type required for bootstrap-only")

              build = spec.get("build", {}) or {}
              requests.append({
                  "path": path,
                  "env": data.get("environment") or data.get("metadata", {}).get("environment"),
                  "region": data.get("region") or data.get("metadata", {}).get("region"),
                  "cluster": cluster.get("name"),
                  "build_id": build.get("build_id") or "",
                  "node_instance_type": instance_type,
              })

          if not requests:
              print("count=0")
              sys.exit(0)

          envs = {r["env"] for r in requests}
          regions = {r["region"] for r in requests}
          if len(envs) != 1 or len(regions) != 1:
              raise SystemExit("Bootstrap-only requests must target a single env/region per run.")

          out = "bootstrap_requests.json"
          with open(out, "w", encoding="utf-8") as handle:
              json.dump(requests, handle)

          print(f"count={len(requests)}")
          print(f"env={requests[0]['env']}")
          print(f"region={requests[0]['region']}")
          print(f"file={out}")
          PY

      - name: Require platform approval label
        if: steps.bootstrap_only.outputs.count != '0' && github.event_name == 'pull_request'
        env:
          EVENT_PATH: ${{ github.event_path }}
        run: |
          python3 - <<'PY'
          import json
          import os
          import sys

          event_path = os.environ.get("EVENT_PATH")
          with open(event_path, "r", encoding="utf-8") as handle:
            event = json.load(handle)

          labels = {label["name"] for label in event.get("pull_request", {}).get("labels", [])}
          approved = {"platform-approval", "eks-approved"}
          if not labels.intersection(approved):
            print("EKS bootstrap requires platform approval.")
            print("Add label: platform-approval (or eks-approved) to proceed.")
            sys.exit(1)
          PY

      - name: Guard non-dev bootstrap
        if: steps.bootstrap_only.outputs.count != '0'
        env:
          ENVIRONMENT: ${{ steps.bootstrap_only.outputs.env }}
        run: |
          set -euo pipefail
          if [[ "$ENVIRONMENT" == "dev" ]]; then
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ inputs.platform_approved }}" != "true" ]]; then
              echo "Platform approval is required. Set platform_approved=true."
              exit 1
            fi
            if [[ "${{ inputs.allow_non_dev }}" != "true" ]]; then
              echo "Non-dev bootstrap requires allow_non_dev=true"
              exit 1
            fi
            exit 0
          fi

      - name: Configure AWS credentials
        if: steps.bootstrap_only.outputs.count != '0'
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          aws-region: ${{ steps.bootstrap_only.outputs.region }}
          role-to-assume: ${{ steps.bootstrap_only.outputs.env == 'dev' && secrets.TF_AWS_IAM_ROLE_DEV_APPLY || steps.bootstrap_only.outputs.env == 'staging' && secrets.TF_AWS_IAM_ROLE_STAGING_APPLY || steps.bootstrap_only.outputs.env == 'prod' && secrets.TF_AWS_IAM_ROLE_PROD_APPLY || secrets.TF_AWS_IAM_ROLE_DEV_APPLY }}

      - name: Run bootstrap-only requests
        if: steps.bootstrap_only.outputs.count != '0'
        env:
          REQUESTS_FILE: ${{ steps.bootstrap_only.outputs.file }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import json
          import os
          import subprocess

          requests = json.load(open(os.environ["REQUESTS_FILE"]))
          for req in requests:
              env = req["env"]
              region = req["region"]
              cluster = req["cluster"]
              build_id = req["build_id"]
              node_instance_type = req["node_instance_type"]

              if not env or not region or not cluster:
                  raise SystemExit(f"Missing env/region/cluster in {req}")

              tfvars_path = f"envs/{env}/terraform.tfvars"
              if not build_id and os.path.exists(tfvars_path):
                  with open(tfvars_path, "r", encoding="utf-8") as handle:
                      for line in handle:
                          if line.strip().startswith("build_id"):
                              build_id = line.split("=", 1)[1].strip().strip('"')
                              break

              env_vars = os.environ.copy()
              env_vars["TF_DIR"] = f"envs/{env}"
              env_vars["NODE_INSTANCE_TYPE"] = node_instance_type
              env_vars["CONFIRM_TF_APPLY"] = "true"
              env_vars["ENABLE_TF_K8S_RESOURCES"] = "true"
              if build_id:
                  env_vars["BUILD_ID"] = build_id

              cmd = [
                  "bash",
                  "bootstrap/10_bootstrap/goldenpath-idp-bootstrap-v3.sh",
                  cluster,
                  region,
                  "kong-system",
              ]
              print(f"Running bootstrap for {cluster} ({env}) in {region}...")
              subprocess.check_call(cmd, env=env_vars)
          PY
