
import os
import glob
import ast

SCRIPTS_DIR = "scripts"
OUTPUT_FILE = "scripts/index.md"

CATEGORIES = {
    "Governance": ["standardize_metadata", "validate_metadata", "pr_guardrails", "platform_health", "check_compliance"],
    "Documentation": ["format_docs", "check_doc_freshness", "check_doc_index_contract", "extract_relationships", "generate_workflow_index", "generate_catalog_docs"],
    "Delivery": ["ecr-build-push", "scaffold_ecr", "render_template", "generate-build-log", "generate-teardown-log", "resolve-cluster-name"],
    "Utilities": ["backfill_metadata", "fix_yaml_syntax", "test_hotfix", "test_platform_health", "reliability-metrics", "migrate_partial_metadata"]
}

def get_docstring(file_path):
    """Extract docstring or first comment from script."""
    try:
        if file_path.endswith(".py"):
            with open(file_path, "r") as f:
                tree = ast.parse(f.read())
            return ast.get_docstring(tree) or "No description provided."
        elif file_path.endswith(".sh"):
            with open(file_path, "r") as f:
                first_line = f.readline()
                if first_line.startswith("#"):
                    # Try to capture a header block if it exists
                    second_line = f.readline()
                    if second_line.startswith("#"):
                        return second_line.strip("# ").strip()
            return "Shell script utility."
    except Exception:
        return "No description available."

    return "No description available."

def get_category(filename):
    base = filename.split(".")[0]
    for cat, scripts in CATEGORIES.items():
        if any(s in base for s in scripts):
            return cat
    return "Utilities"

def generate_index():
    scripts = []
    # Find both .py and .sh files
    for file_path in glob.glob(f"{SCRIPTS_DIR}/*.py") + glob.glob(f"{SCRIPTS_DIR}/*.sh"):
        name = os.path.basename(file_path)
        if name in ["__init__.py", "generate_script_index.py"]:
            continue

        category = get_category(name)
        description = get_docstring(file_path)
        # Taking just the first line of docstring for brevity in table
        if description:
            description = description.split('\n')[0]

        scripts.append({
            "name": name,
            "category": category,
            "path": file_path,
            "description": description
        })

    # Generate MD
    lines = [
        "---",
        "id: PLATFORM_SCRIPTS_INDEX",
        "title: Platform Automation Scripts Index (Auto-Generated)",
        "type: documentation",
        "category: governance",
        "version: '1.0'",
        "owner: platform-team",
        "status: active",
        "risk_profile:",
        "  production_impact: low",
        "  security_risk: none",
        "  coupling_risk: low",
        "reliability:",
        "  rollback_strategy: git-revert",
        "  observability_tier: bronze",
        "lifecycle: active",
        "supported_until: '2028-01-01'",
        "last_updated: 2026-01-06",
        "dependencies:",
        "  - python3",
        "  - pyyaml",
        "---",
        "",
        "# Platform Automation Scripts Index (Auto-Generated)",
        "",
        "> **Auto-Generated**: This file is generated by `scripts/generate_script_index.py`.",
        "",
        "This directory contains the automation engine powering the GoldenPath IDP.",
        ""
    ]

    # Sort scripts by category then name
    sorted_scripts = sorted(scripts, key=lambda x: (x['category'], x['name']))
    current_cat = None

    for script in sorted_scripts:
        if script['category'] != current_cat:
            current_cat = script['category']
            lines.append(f"## {current_cat}")
            lines.append("")
            lines.append("| Script | Description |")
            lines.append("| :--- | :--- |")

        link = f"[{script['name']}]({script['name']})"
        desc = script['description'] or "Utility script"
        lines.append(f"| {link} | {desc} |")

        # Add spacing after table if category changes (logic requires peeking or simpler structure)
        # Simplified: tables will just run together if not careful, so let's break tables by category

    # Clean up empty lines between tables
    final_content = []
    in_table = False
    for line in lines:
        if line.startswith("| Script"):
            if in_table: final_content.append("")
            in_table = True
        if line.startswith("##"):
            in_table = False
            final_content.append("")
        final_content.append(line)

    return "\n".join(final_content)

if __name__ == "__main__":
    import sys

    # Check mode: Fail if any script is missing a description
    if "--validate" in sys.argv:
        missing_docs = []
        # Re-run scanning logic only (inefficient but simple reuse)
        for file_path in glob.glob(f"{SCRIPTS_DIR}/*.py") + glob.glob(f"{SCRIPTS_DIR}/*.sh"):
            name = os.path.basename(file_path)
            if name in ["__init__.py", "generate_script_index.py"]:
                continue
            desc = get_docstring(file_path)
            if not desc or desc.startswith("No description"):
                missing_docs.append(name)

        # Drift Check
        current_content = ""
        if os.path.exists(OUTPUT_FILE):
            with open(OUTPUT_FILE, "r") as f:
                current_content = f.read()

        generated_content = generate_index()
        is_drifted = (current_content.strip() != generated_content.strip())

        if missing_docs or is_drifted:
            if missing_docs:
                print("❌ Governance Failure: The following scripts are missing docstrings/headers:")
                for s in missing_docs:
                    print(f"   - {s}")
            if is_drifted:
                print(f"❌ Drift Detected: {OUTPUT_FILE} is out of sync with physical scripts.")
            sys.exit(1)
        else:
            print("✅ All scripts are documented and index is up-to-date.")
            sys.exit(0)

    # Normal mode: Generate file
    content = generate_index()
    with open(OUTPUT_FILE, "w") as f:
        f.write(content)
    print(f"✅ Generated {OUTPUT_FILE}")
